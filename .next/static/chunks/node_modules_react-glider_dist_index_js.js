/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_react-glider_dist_index_js"],{

/***/ "./node_modules/glider-js/glider.js":
/*!******************************************!*\
  !*** ./node_modules/glider-js/glider.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* @preserve\n    _____ __ _     __                _\n   / ___// /(_)___/ /___  ____      (_)___\n  / (_ // // // _  // -_)/ __/_    / /(_-<\n  \\___//_//_/ \\_,_/ \\__//_/  (_)__/ //___/\n                              |___/\n\n  Version: 1.6.6\n  Author: Nick Piscitelli (pickykneee)\n  Website: https://nickpiscitelli.com\n  Documentation: http://nickpiscitelli.github.io/Glider.js\n  License: MIT License\n  Release Date: October 25th, 2018\n\n*/\n\n/* global define */\n\n(function (factory) {\n   true\n    ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n    : 0\n})(function () {\n  ('use strict') // eslint-disable-line no-unused-expressions\n\n  /* globals window:true */\n  var _window = typeof window !== 'undefined' ? window : this\n\n  var Glider = (_window.Glider = function (element, settings) {\n    var _ = this\n\n    if (element._glider) return element._glider\n\n    _.ele = element\n    _.ele.classList.add('glider')\n\n    // expose glider object to its DOM element\n    _.ele._glider = _\n\n    // merge user setting with defaults\n    _.opt = Object.assign(\n      {},\n      {\n        slidesToScroll: 1,\n        slidesToShow: 1,\n        resizeLock: true,\n        duration: 0.5,\n        // easeInQuad\n        easing: function (x, t, b, c, d) {\n          return c * (t /= d) * t + b\n        }\n      },\n      settings\n    )\n\n    // set defaults\n    _.animate_id = _.page = _.slide = 0\n    _.arrows = {}\n\n    // preserve original options to\n    // extend breakpoint settings\n    _._opt = _.opt\n\n    if (_.opt.skipTrack) {\n      // first and only child is the track\n      _.track = _.ele.children[0]\n    } else {\n      // create track and wrap slides\n      _.track = document.createElement('div')\n      _.ele.appendChild(_.track)\n      while (_.ele.children.length !== 1) {\n        _.track.appendChild(_.ele.children[0])\n      }\n    }\n\n    _.track.classList.add('glider-track')\n\n    // start glider\n    _.init()\n\n    // set events\n    _.resize = _.init.bind(_, true)\n    _.event(_.ele, 'add', {\n      scroll: _.updateControls.bind(_)\n    })\n    _.event(_window, 'add', {\n      resize: _.resize\n    })\n  })\n\n  var gliderPrototype = Glider.prototype\n  gliderPrototype.init = function (refresh, paging) {\n    var _ = this\n\n    var width = 0\n\n    var height = 0\n\n    _.slides = _.track.children;\n\n    [].forEach.call(_.slides, function (_) {\n      _.classList.add('glider-slide')\n    })\n\n    _.containerWidth = _.ele.clientWidth\n\n    var breakpointChanged = _.settingsBreakpoint()\n    if (!paging) paging = breakpointChanged\n\n    if (_.opt.slidesToShow === 'auto' || _.opt._autoSlide) {\n      var slideCount = _.containerWidth / _.opt.itemWidth\n\n      _.opt._autoSlide = _.opt.slidesToShow = _.opt.exactWidth\n        ? slideCount\n        : Math.floor(slideCount)\n    }\n    if (_.opt.slidesToScroll === 'auto') {\n      _.opt.slidesToScroll = Math.floor(_.opt.slidesToShow)\n    }\n\n    _.itemWidth = _.opt.exactWidth\n      ? _.opt.itemWidth\n      : _.containerWidth / _.opt.slidesToShow;\n\n    // set slide dimensions\n    [].forEach.call(_.slides, function (__) {\n      __.style.height = 'auto'\n      __.style.width = _.itemWidth + 'px'\n      width += _.itemWidth\n      height = Math.max(__.offsetHeight, height)\n    })\n\n    _.track.style.width = width + 'px'\n    _.trackWidth = width\n\n    _.opt.resizeLock && _.scrollTo(_.slide * _.itemWidth, 0)\n\n    if (breakpointChanged || paging) {\n      _.bindArrows()\n      _.buildDots()\n      _.bindDrag()\n    }\n\n    _.updateControls()\n\n    _.emit(refresh ? 'refresh ' : 'loaded')\n  }\n\n  gliderPrototype.bindDrag = function () {\n    var _ = this\n    _.mouse = _.mouse || _.handleMouse.bind(_)\n\n    var mouseup = function () {\n      _.mouseDown = undefined\n      _.ele.classList.remove('drag')\n    }\n\n    var events = {\n      mouseup: mouseup,\n      mouseleave: mouseup,\n      mousedown: function (e) {\n        _.mouseDown = e.clientX\n        _.ele.classList.add('drag')\n      },\n      mousemove: _.mouse\n    }\n\n    _.ele.classList.toggle('draggable', _.opt.draggable === true)\n    _.event(_.ele, 'remove', events)\n    if (_.opt.draggable) _.event(_.ele, 'add', events)\n  }\n\n  gliderPrototype.buildDots = function () {\n    var _ = this\n\n    if (!_.opt.dots) {\n      if (_.dots) _.dots.innerHTML = ''\n      return\n    }\n\n    if (typeof _.opt.dots === 'string') {\n      _.dots = document.querySelector(_.opt.dots)\n    } else _.dots = _.opt.dots\n    if (!_.dots) return\n\n    _.dots.innerHTML = ''\n    _.dots.className = 'glider-dots'\n\n    for (var i = 0; i < Math.ceil(_.slides.length / _.opt.slidesToShow); ++i) {\n      var dot = document.createElement('button')\n      dot.dataset.index = i\n      dot.setAttribute('aria-label', 'Page ' + (i + 1))\n      dot.className = 'glider-dot ' + (i ? '' : 'active')\n      _.event(dot, 'add', {\n        click: _.scrollItem.bind(_, i, true)\n      })\n      _.dots.appendChild(dot)\n    }\n  }\n\n  gliderPrototype.bindArrows = function () {\n    var _ = this\n    if (!_.opt.arrows) {\n      Object.keys(_.arrows).forEach(function (direction) {\n        var element = _.arrows[direction]\n        _.event(element, 'remove', { click: element._func })\n      })\n      return\n    }\n    ['prev', 'next'].forEach(function (direction) {\n      var arrow = _.opt.arrows[direction]\n      if (arrow) {\n        if (typeof arrow === 'string') arrow = document.querySelector(arrow)\n        arrow._func = arrow._func || _.scrollItem.bind(_, direction)\n        _.event(arrow, 'remove', {\n          click: arrow._func\n        })\n        _.event(arrow, 'add', {\n          click: arrow._func\n        })\n        _.arrows[direction] = arrow\n      }\n    })\n  }\n\n  gliderPrototype.updateControls = function (event) {\n    var _ = this\n\n    if (event && !_.opt.scrollPropagate) {\n      event.stopPropagation()\n    }\n\n    var disableArrows = _.containerWidth >= _.trackWidth\n\n    if (!_.opt.rewind) {\n      if (_.arrows.prev) {\n        _.arrows.prev.classList.toggle(\n          'disabled',\n          _.ele.scrollLeft <= 0 || disableArrows\n        )\n      }\n      if (_.arrows.next) {\n        _.arrows.next.classList.toggle(\n          'disabled',\n          _.ele.scrollLeft + _.containerWidth >= Math.floor(_.trackWidth) ||\n            disableArrows\n        )\n      }\n    }\n\n    _.slide = Math.round(_.ele.scrollLeft / _.itemWidth)\n    _.page = Math.round(_.ele.scrollLeft / _.containerWidth)\n\n    var middle = _.slide + Math.floor(Math.floor(_.opt.slidesToShow) / 2)\n\n    var extraMiddle = Math.floor(_.opt.slidesToShow) % 2 ? 0 : middle + 1\n    if (Math.floor(_.opt.slidesToShow) === 1) {\n      extraMiddle = 0\n    }\n\n    // the last page may be less than one half of a normal page width so\n    // the page is rounded down. when at the end, force the page to turn\n    if (_.ele.scrollLeft + _.containerWidth >= Math.floor(_.trackWidth)) {\n      _.page = _.dots ? _.dots.children.length - 1 : 0\n    }\n\n    [].forEach.call(_.slides, function (slide, index) {\n      var slideClasses = slide.classList\n\n      var wasVisible = slideClasses.contains('visible')\n\n      var start = _.ele.scrollLeft\n\n      var end = _.ele.scrollLeft + _.containerWidth\n\n      var itemStart = _.itemWidth * index\n\n      var itemEnd = itemStart + _.itemWidth;\n\n      [].forEach.call(slideClasses, function (className) {\n        /^left|right/.test(className) && slideClasses.remove(className)\n      })\n      slideClasses.toggle('active', _.slide === index)\n      if (middle === index || (extraMiddle && extraMiddle === index)) {\n        slideClasses.add('center')\n      } else {\n        slideClasses.remove('center')\n        slideClasses.add(\n          [\n            index < middle ? 'left' : 'right',\n            Math.abs(index - (index < middle ? middle : extraMiddle || middle))\n          ].join('-')\n        )\n      }\n\n      var isVisible =\n        Math.ceil(itemStart) >= start && Math.ceil(itemEnd) <= end\n      slideClasses.toggle('visible', isVisible)\n      if (isVisible !== wasVisible) {\n        _.emit('slide-' + (isVisible ? 'visible' : 'hidden'), {\n          slide: index\n        })\n      }\n    })\n    if (_.dots) {\n      [].forEach.call(_.dots.children, function (dot, index) {\n        dot.classList.toggle('active', _.page === index)\n      })\n    }\n\n    if (event && _.opt.scrollLock) {\n      clearTimeout(_.scrollLock)\n      _.scrollLock = setTimeout(function () {\n        clearTimeout(_.scrollLock)\n        if ((_.ele.scrollLeft / _.itemWidth) % 1) {\n          _.scrollItem(_.round(_.ele.scrollLeft / _.itemWidth))\n        }\n      }, _.opt.scrollLockDelay || 250)\n    }\n  }\n\n  gliderPrototype.scrollItem = function (slide, dot, e) {\n    if (e) e.preventDefault()\n\n    var _ = this\n\n    var originalSlide = slide\n    ++_.animate_id\n\n    if (dot === true) {\n      slide = slide * _.containerWidth\n      slide = Math.round(slide / _.itemWidth) * _.itemWidth\n    } else {\n      if (typeof slide === 'string') {\n        var backwards = slide === 'prev'\n\n        // use precise location if fractional slides are on\n        if (_.opt.slidesToScroll % 1 || _.opt.slidesToShow % 1) {\n          slide = _.round(_.ele.scrollLeft / _.itemWidth)\n        } else {\n          slide = _.slide\n        }\n\n        if (backwards) slide -= _.opt.slidesToScroll\n        else slide += _.opt.slidesToScroll\n\n        if (_.opt.rewind) {\n          var scrollLeft = _.ele.scrollLeft\n          slide =\n            backwards && !scrollLeft\n              ? _.slides.length\n              : !backwards &&\n                scrollLeft + _.containerWidth >= Math.floor(_.trackWidth)\n                ? 0\n                : slide\n        }\n      }\n\n      slide = Math.max(Math.min(slide, _.slides.length), 0)\n\n      _.slide = slide\n      slide = _.itemWidth * slide\n    }\n\n    _.scrollTo(\n      slide,\n      _.opt.duration * Math.abs(_.ele.scrollLeft - slide),\n      function () {\n        _.updateControls()\n        _.emit('animated', {\n          value: originalSlide,\n          type:\n            typeof originalSlide === 'string' ? 'arrow' : dot ? 'dot' : 'slide'\n        })\n      }\n    )\n\n    return false\n  }\n\n  gliderPrototype.settingsBreakpoint = function () {\n    var _ = this\n\n    var resp = _._opt.responsive\n\n    if (resp) {\n      // Sort the breakpoints in mobile first order\n      resp.sort(function (a, b) {\n        return b.breakpoint - a.breakpoint\n      })\n\n      for (var i = 0; i < resp.length; ++i) {\n        var size = resp[i]\n        if (_window.innerWidth >= size.breakpoint) {\n          if (_.breakpoint !== size.breakpoint) {\n            _.opt = Object.assign({}, _._opt, size.settings)\n            _.breakpoint = size.breakpoint\n            return true\n          }\n          return false\n        }\n      }\n    }\n    // set back to defaults in case they were overriden\n    var breakpointChanged = _.breakpoint !== 0\n    _.opt = Object.assign({}, _._opt)\n    _.breakpoint = 0\n    return breakpointChanged\n  }\n\n  gliderPrototype.scrollTo = function (scrollTarget, scrollDuration, callback) {\n    var _ = this\n\n    var start = new Date().getTime()\n\n    var animateIndex = _.animate_id\n\n    var animate = function () {\n      var now = new Date().getTime() - start\n      _.ele.scrollLeft =\n        _.ele.scrollLeft +\n        (scrollTarget - _.ele.scrollLeft) *\n          _.opt.easing(0, now, 0, 1, scrollDuration)\n      if (now < scrollDuration && animateIndex === _.animate_id) {\n        _window.requestAnimationFrame(animate)\n      } else {\n        _.ele.scrollLeft = scrollTarget\n        callback && callback.call(_)\n      }\n    }\n\n    _window.requestAnimationFrame(animate)\n  }\n\n  gliderPrototype.removeItem = function (index) {\n    var _ = this\n\n    if (_.slides.length) {\n      _.track.removeChild(_.slides[index])\n      _.refresh(true)\n      _.emit('remove')\n    }\n  }\n\n  gliderPrototype.addItem = function (ele) {\n    var _ = this\n\n    _.track.appendChild(ele)\n    _.refresh(true)\n    _.emit('add')\n  }\n\n  gliderPrototype.handleMouse = function (e) {\n    var _ = this\n    if (_.mouseDown) {\n      _.ele.scrollLeft +=\n        (_.mouseDown - e.clientX) * (_.opt.dragVelocity || 3.3)\n      _.mouseDown = e.clientX\n    }\n  }\n\n  // used to round to the nearest 0.XX fraction\n  gliderPrototype.round = function (double) {\n    var _ = this\n    var step = _.opt.slidesToScroll % 1 || 1\n    var inv = 1.0 / step\n    return Math.round(double * inv) / inv\n  }\n\n  gliderPrototype.refresh = function (paging) {\n    var _ = this\n    _.init(true, paging)\n  }\n\n  gliderPrototype.setOption = function (opt, global) {\n    var _ = this\n\n    if (_.breakpoint && !global) {\n      _._opt.responsive.forEach(function (v) {\n        if (v.breakpoint === _.breakpoint) {\n          v.settings = Object.assign({}, v.settings, opt)\n        }\n      })\n    } else {\n      _._opt = Object.assign({}, _._opt, opt)\n    }\n\n    _.breakpoint = 0\n    _.settingsBreakpoint()\n  }\n\n  gliderPrototype.destroy = function () {\n    var _ = this\n\n    var replace = _.ele.cloneNode(true)\n\n    var clear = function (ele) {\n      ele.removeAttribute('style');\n      [].forEach.call(ele.classList, function (className) {\n        /^glider/.test(className) && ele.classList.remove(className)\n      })\n    }\n    // remove track\n    replace.children[0].outerHTML = replace.children[0].innerHTML\n    clear(replace);\n    [].forEach.call(replace.getElementsByTagName('*'), clear)\n    _.ele.parentNode.replaceChild(replace, _.ele)\n    _.event(_window, 'remove', {\n      resize: _.resize\n    })\n    _.emit('destroy')\n  }\n\n  gliderPrototype.emit = function (name, arg) {\n    var _ = this\n\n    var e = new _window.CustomEvent('glider-' + name, {\n      bubbles: !_.opt.eventPropagate,\n      detail: arg\n    })\n    _.ele.dispatchEvent(e)\n  }\n\n  gliderPrototype.event = function (ele, type, args) {\n    var eventHandler = ele[type + 'EventListener'].bind(ele)\n    Object.keys(args).forEach(function (k) {\n      eventHandler(k, args[k])\n    })\n  }\n\n  return Glider\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2xpZGVyLWpzL2dsaWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxLQUEwQztBQUM1QyxNQUFNLG9DQUFPLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUNyQixNQUFNLENBRVc7QUFDakIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IscURBQXFEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dsaWRlci1qcy9nbGlkZXIuanM/YmUxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAcHJlc2VydmVcbiAgICBfX19fXyBfXyBfICAgICBfXyAgICAgICAgICAgICAgICBfXG4gICAvIF9fXy8vIC8oXylfX18vIC9fX18gIF9fX18gICAgICAoXylfX19cbiAgLyAoXyAvLyAvLyAvLyBfICAvLyAtXykvIF9fL18gICAgLyAvKF8tPFxuICBcXF9fXy8vXy8vXy8gXFxfLF8vIFxcX18vL18vICAoXylfXy8gLy9fX18vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8X19fL1xuXG4gIFZlcnNpb246IDEuNi42XG4gIEF1dGhvcjogTmljayBQaXNjaXRlbGxpIChwaWNreWtuZWVlKVxuICBXZWJzaXRlOiBodHRwczovL25pY2twaXNjaXRlbGxpLmNvbVxuICBEb2N1bWVudGF0aW9uOiBodHRwOi8vbmlja3Bpc2NpdGVsbGkuZ2l0aHViLmlvL0dsaWRlci5qc1xuICBMaWNlbnNlOiBNSVQgTGljZW5zZVxuICBSZWxlYXNlIERhdGU6IE9jdG9iZXIgMjV0aCwgMjAxOFxuXG4qL1xuXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICA/IGRlZmluZShmYWN0b3J5KVxuICAgIDogdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnXG4gICAgICA/IChtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSlcbiAgICAgIDogZmFjdG9yeSgpXG59KShmdW5jdGlvbiAoKSB7XG4gICgndXNlIHN0cmljdCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgLyogZ2xvYmFscyB3aW5kb3c6dHJ1ZSAqL1xuICB2YXIgX3dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpc1xuXG4gIHZhciBHbGlkZXIgPSAoX3dpbmRvdy5HbGlkZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgXyA9IHRoaXNcblxuICAgIGlmIChlbGVtZW50Ll9nbGlkZXIpIHJldHVybiBlbGVtZW50Ll9nbGlkZXJcblxuICAgIF8uZWxlID0gZWxlbWVudFxuICAgIF8uZWxlLmNsYXNzTGlzdC5hZGQoJ2dsaWRlcicpXG5cbiAgICAvLyBleHBvc2UgZ2xpZGVyIG9iamVjdCB0byBpdHMgRE9NIGVsZW1lbnRcbiAgICBfLmVsZS5fZ2xpZGVyID0gX1xuXG4gICAgLy8gbWVyZ2UgdXNlciBzZXR0aW5nIHdpdGggZGVmYXVsdHNcbiAgICBfLm9wdCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIHtcbiAgICAgICAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gICAgICAgIHNsaWRlc1RvU2hvdzogMSxcbiAgICAgICAgcmVzaXplTG9jazogdHJ1ZSxcbiAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgLy8gZWFzZUluUXVhZFxuICAgICAgICBlYXNpbmc6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKyBiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXR0aW5nc1xuICAgIClcblxuICAgIC8vIHNldCBkZWZhdWx0c1xuICAgIF8uYW5pbWF0ZV9pZCA9IF8ucGFnZSA9IF8uc2xpZGUgPSAwXG4gICAgXy5hcnJvd3MgPSB7fVxuXG4gICAgLy8gcHJlc2VydmUgb3JpZ2luYWwgb3B0aW9ucyB0b1xuICAgIC8vIGV4dGVuZCBicmVha3BvaW50IHNldHRpbmdzXG4gICAgXy5fb3B0ID0gXy5vcHRcblxuICAgIGlmIChfLm9wdC5za2lwVHJhY2spIHtcbiAgICAgIC8vIGZpcnN0IGFuZCBvbmx5IGNoaWxkIGlzIHRoZSB0cmFja1xuICAgICAgXy50cmFjayA9IF8uZWxlLmNoaWxkcmVuWzBdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSB0cmFjayBhbmQgd3JhcCBzbGlkZXNcbiAgICAgIF8udHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgXy5lbGUuYXBwZW5kQ2hpbGQoXy50cmFjaylcbiAgICAgIHdoaWxlIChfLmVsZS5jaGlsZHJlbi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgXy50cmFjay5hcHBlbmRDaGlsZChfLmVsZS5jaGlsZHJlblswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfLnRyYWNrLmNsYXNzTGlzdC5hZGQoJ2dsaWRlci10cmFjaycpXG5cbiAgICAvLyBzdGFydCBnbGlkZXJcbiAgICBfLmluaXQoKVxuXG4gICAgLy8gc2V0IGV2ZW50c1xuICAgIF8ucmVzaXplID0gXy5pbml0LmJpbmQoXywgdHJ1ZSlcbiAgICBfLmV2ZW50KF8uZWxlLCAnYWRkJywge1xuICAgICAgc2Nyb2xsOiBfLnVwZGF0ZUNvbnRyb2xzLmJpbmQoXylcbiAgICB9KVxuICAgIF8uZXZlbnQoX3dpbmRvdywgJ2FkZCcsIHtcbiAgICAgIHJlc2l6ZTogXy5yZXNpemVcbiAgICB9KVxuICB9KVxuXG4gIHZhciBnbGlkZXJQcm90b3R5cGUgPSBHbGlkZXIucHJvdG90eXBlXG4gIGdsaWRlclByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHJlZnJlc2gsIHBhZ2luZykge1xuICAgIHZhciBfID0gdGhpc1xuXG4gICAgdmFyIHdpZHRoID0gMFxuXG4gICAgdmFyIGhlaWdodCA9IDBcblxuICAgIF8uc2xpZGVzID0gXy50cmFjay5jaGlsZHJlbjtcblxuICAgIFtdLmZvckVhY2guY2FsbChfLnNsaWRlcywgZnVuY3Rpb24gKF8pIHtcbiAgICAgIF8uY2xhc3NMaXN0LmFkZCgnZ2xpZGVyLXNsaWRlJylcbiAgICB9KVxuXG4gICAgXy5jb250YWluZXJXaWR0aCA9IF8uZWxlLmNsaWVudFdpZHRoXG5cbiAgICB2YXIgYnJlYWtwb2ludENoYW5nZWQgPSBfLnNldHRpbmdzQnJlYWtwb2ludCgpXG4gICAgaWYgKCFwYWdpbmcpIHBhZ2luZyA9IGJyZWFrcG9pbnRDaGFuZ2VkXG5cbiAgICBpZiAoXy5vcHQuc2xpZGVzVG9TaG93ID09PSAnYXV0bycgfHwgXy5vcHQuX2F1dG9TbGlkZSkge1xuICAgICAgdmFyIHNsaWRlQ291bnQgPSBfLmNvbnRhaW5lcldpZHRoIC8gXy5vcHQuaXRlbVdpZHRoXG5cbiAgICAgIF8ub3B0Ll9hdXRvU2xpZGUgPSBfLm9wdC5zbGlkZXNUb1Nob3cgPSBfLm9wdC5leGFjdFdpZHRoXG4gICAgICAgID8gc2xpZGVDb3VudFxuICAgICAgICA6IE1hdGguZmxvb3Ioc2xpZGVDb3VudClcbiAgICB9XG4gICAgaWYgKF8ub3B0LnNsaWRlc1RvU2Nyb2xsID09PSAnYXV0bycpIHtcbiAgICAgIF8ub3B0LnNsaWRlc1RvU2Nyb2xsID0gTWF0aC5mbG9vcihfLm9wdC5zbGlkZXNUb1Nob3cpXG4gICAgfVxuXG4gICAgXy5pdGVtV2lkdGggPSBfLm9wdC5leGFjdFdpZHRoXG4gICAgICA/IF8ub3B0Lml0ZW1XaWR0aFxuICAgICAgOiBfLmNvbnRhaW5lcldpZHRoIC8gXy5vcHQuc2xpZGVzVG9TaG93O1xuXG4gICAgLy8gc2V0IHNsaWRlIGRpbWVuc2lvbnNcbiAgICBbXS5mb3JFYWNoLmNhbGwoXy5zbGlkZXMsIGZ1bmN0aW9uIChfXykge1xuICAgICAgX18uc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nXG4gICAgICBfXy5zdHlsZS53aWR0aCA9IF8uaXRlbVdpZHRoICsgJ3B4J1xuICAgICAgd2lkdGggKz0gXy5pdGVtV2lkdGhcbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KF9fLm9mZnNldEhlaWdodCwgaGVpZ2h0KVxuICAgIH0pXG5cbiAgICBfLnRyYWNrLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnXG4gICAgXy50cmFja1dpZHRoID0gd2lkdGhcblxuICAgIF8ub3B0LnJlc2l6ZUxvY2sgJiYgXy5zY3JvbGxUbyhfLnNsaWRlICogXy5pdGVtV2lkdGgsIDApXG5cbiAgICBpZiAoYnJlYWtwb2ludENoYW5nZWQgfHwgcGFnaW5nKSB7XG4gICAgICBfLmJpbmRBcnJvd3MoKVxuICAgICAgXy5idWlsZERvdHMoKVxuICAgICAgXy5iaW5kRHJhZygpXG4gICAgfVxuXG4gICAgXy51cGRhdGVDb250cm9scygpXG5cbiAgICBfLmVtaXQocmVmcmVzaCA/ICdyZWZyZXNoICcgOiAnbG9hZGVkJylcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5iaW5kRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgXyA9IHRoaXNcbiAgICBfLm1vdXNlID0gXy5tb3VzZSB8fCBfLmhhbmRsZU1vdXNlLmJpbmQoXylcblxuICAgIHZhciBtb3VzZXVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgXy5tb3VzZURvd24gPSB1bmRlZmluZWRcbiAgICAgIF8uZWxlLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWcnKVxuICAgIH1cblxuICAgIHZhciBldmVudHMgPSB7XG4gICAgICBtb3VzZXVwOiBtb3VzZXVwLFxuICAgICAgbW91c2VsZWF2ZTogbW91c2V1cCxcbiAgICAgIG1vdXNlZG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgXy5tb3VzZURvd24gPSBlLmNsaWVudFhcbiAgICAgICAgXy5lbGUuY2xhc3NMaXN0LmFkZCgnZHJhZycpXG4gICAgICB9LFxuICAgICAgbW91c2Vtb3ZlOiBfLm1vdXNlXG4gICAgfVxuXG4gICAgXy5lbGUuY2xhc3NMaXN0LnRvZ2dsZSgnZHJhZ2dhYmxlJywgXy5vcHQuZHJhZ2dhYmxlID09PSB0cnVlKVxuICAgIF8uZXZlbnQoXy5lbGUsICdyZW1vdmUnLCBldmVudHMpXG4gICAgaWYgKF8ub3B0LmRyYWdnYWJsZSkgXy5ldmVudChfLmVsZSwgJ2FkZCcsIGV2ZW50cylcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5idWlsZERvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICBpZiAoIV8ub3B0LmRvdHMpIHtcbiAgICAgIGlmIChfLmRvdHMpIF8uZG90cy5pbm5lckhUTUwgPSAnJ1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfLm9wdC5kb3RzID09PSAnc3RyaW5nJykge1xuICAgICAgXy5kb3RzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihfLm9wdC5kb3RzKVxuICAgIH0gZWxzZSBfLmRvdHMgPSBfLm9wdC5kb3RzXG4gICAgaWYgKCFfLmRvdHMpIHJldHVyblxuXG4gICAgXy5kb3RzLmlubmVySFRNTCA9ICcnXG4gICAgXy5kb3RzLmNsYXNzTmFtZSA9ICdnbGlkZXItZG90cydcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5jZWlsKF8uc2xpZGVzLmxlbmd0aCAvIF8ub3B0LnNsaWRlc1RvU2hvdyk7ICsraSkge1xuICAgICAgdmFyIGRvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgICBkb3QuZGF0YXNldC5pbmRleCA9IGlcbiAgICAgIGRvdC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnUGFnZSAnICsgKGkgKyAxKSlcbiAgICAgIGRvdC5jbGFzc05hbWUgPSAnZ2xpZGVyLWRvdCAnICsgKGkgPyAnJyA6ICdhY3RpdmUnKVxuICAgICAgXy5ldmVudChkb3QsICdhZGQnLCB7XG4gICAgICAgIGNsaWNrOiBfLnNjcm9sbEl0ZW0uYmluZChfLCBpLCB0cnVlKVxuICAgICAgfSlcbiAgICAgIF8uZG90cy5hcHBlbmRDaGlsZChkb3QpXG4gICAgfVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLmJpbmRBcnJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF8gPSB0aGlzXG4gICAgaWYgKCFfLm9wdC5hcnJvd3MpIHtcbiAgICAgIE9iamVjdC5rZXlzKF8uYXJyb3dzKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBfLmFycm93c1tkaXJlY3Rpb25dXG4gICAgICAgIF8uZXZlbnQoZWxlbWVudCwgJ3JlbW92ZScsIHsgY2xpY2s6IGVsZW1lbnQuX2Z1bmMgfSlcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgWydwcmV2JywgJ25leHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBhcnJvdyA9IF8ub3B0LmFycm93c1tkaXJlY3Rpb25dXG4gICAgICBpZiAoYXJyb3cpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcnJvdyA9PT0gJ3N0cmluZycpIGFycm93ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcnJvdylcbiAgICAgICAgYXJyb3cuX2Z1bmMgPSBhcnJvdy5fZnVuYyB8fCBfLnNjcm9sbEl0ZW0uYmluZChfLCBkaXJlY3Rpb24pXG4gICAgICAgIF8uZXZlbnQoYXJyb3csICdyZW1vdmUnLCB7XG4gICAgICAgICAgY2xpY2s6IGFycm93Ll9mdW5jXG4gICAgICAgIH0pXG4gICAgICAgIF8uZXZlbnQoYXJyb3csICdhZGQnLCB7XG4gICAgICAgICAgY2xpY2s6IGFycm93Ll9mdW5jXG4gICAgICAgIH0pXG4gICAgICAgIF8uYXJyb3dzW2RpcmVjdGlvbl0gPSBhcnJvd1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBnbGlkZXJQcm90b3R5cGUudXBkYXRlQ29udHJvbHMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgXyA9IHRoaXNcblxuICAgIGlmIChldmVudCAmJiAhXy5vcHQuc2Nyb2xsUHJvcGFnYXRlKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgIH1cblxuICAgIHZhciBkaXNhYmxlQXJyb3dzID0gXy5jb250YWluZXJXaWR0aCA+PSBfLnRyYWNrV2lkdGhcblxuICAgIGlmICghXy5vcHQucmV3aW5kKSB7XG4gICAgICBpZiAoXy5hcnJvd3MucHJldikge1xuICAgICAgICBfLmFycm93cy5wcmV2LmNsYXNzTGlzdC50b2dnbGUoXG4gICAgICAgICAgJ2Rpc2FibGVkJyxcbiAgICAgICAgICBfLmVsZS5zY3JvbGxMZWZ0IDw9IDAgfHwgZGlzYWJsZUFycm93c1xuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoXy5hcnJvd3MubmV4dCkge1xuICAgICAgICBfLmFycm93cy5uZXh0LmNsYXNzTGlzdC50b2dnbGUoXG4gICAgICAgICAgJ2Rpc2FibGVkJyxcbiAgICAgICAgICBfLmVsZS5zY3JvbGxMZWZ0ICsgXy5jb250YWluZXJXaWR0aCA+PSBNYXRoLmZsb29yKF8udHJhY2tXaWR0aCkgfHxcbiAgICAgICAgICAgIGRpc2FibGVBcnJvd3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIF8uc2xpZGUgPSBNYXRoLnJvdW5kKF8uZWxlLnNjcm9sbExlZnQgLyBfLml0ZW1XaWR0aClcbiAgICBfLnBhZ2UgPSBNYXRoLnJvdW5kKF8uZWxlLnNjcm9sbExlZnQgLyBfLmNvbnRhaW5lcldpZHRoKVxuXG4gICAgdmFyIG1pZGRsZSA9IF8uc2xpZGUgKyBNYXRoLmZsb29yKE1hdGguZmxvb3IoXy5vcHQuc2xpZGVzVG9TaG93KSAvIDIpXG5cbiAgICB2YXIgZXh0cmFNaWRkbGUgPSBNYXRoLmZsb29yKF8ub3B0LnNsaWRlc1RvU2hvdykgJSAyID8gMCA6IG1pZGRsZSArIDFcbiAgICBpZiAoTWF0aC5mbG9vcihfLm9wdC5zbGlkZXNUb1Nob3cpID09PSAxKSB7XG4gICAgICBleHRyYU1pZGRsZSA9IDBcbiAgICB9XG5cbiAgICAvLyB0aGUgbGFzdCBwYWdlIG1heSBiZSBsZXNzIHRoYW4gb25lIGhhbGYgb2YgYSBub3JtYWwgcGFnZSB3aWR0aCBzb1xuICAgIC8vIHRoZSBwYWdlIGlzIHJvdW5kZWQgZG93bi4gd2hlbiBhdCB0aGUgZW5kLCBmb3JjZSB0aGUgcGFnZSB0byB0dXJuXG4gICAgaWYgKF8uZWxlLnNjcm9sbExlZnQgKyBfLmNvbnRhaW5lcldpZHRoID49IE1hdGguZmxvb3IoXy50cmFja1dpZHRoKSkge1xuICAgICAgXy5wYWdlID0gXy5kb3RzID8gXy5kb3RzLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwXG4gICAgfVxuXG4gICAgW10uZm9yRWFjaC5jYWxsKF8uc2xpZGVzLCBmdW5jdGlvbiAoc2xpZGUsIGluZGV4KSB7XG4gICAgICB2YXIgc2xpZGVDbGFzc2VzID0gc2xpZGUuY2xhc3NMaXN0XG5cbiAgICAgIHZhciB3YXNWaXNpYmxlID0gc2xpZGVDbGFzc2VzLmNvbnRhaW5zKCd2aXNpYmxlJylcblxuICAgICAgdmFyIHN0YXJ0ID0gXy5lbGUuc2Nyb2xsTGVmdFxuXG4gICAgICB2YXIgZW5kID0gXy5lbGUuc2Nyb2xsTGVmdCArIF8uY29udGFpbmVyV2lkdGhcblxuICAgICAgdmFyIGl0ZW1TdGFydCA9IF8uaXRlbVdpZHRoICogaW5kZXhcblxuICAgICAgdmFyIGl0ZW1FbmQgPSBpdGVtU3RhcnQgKyBfLml0ZW1XaWR0aDtcblxuICAgICAgW10uZm9yRWFjaC5jYWxsKHNsaWRlQ2xhc3NlcywgZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAvXmxlZnR8cmlnaHQvLnRlc3QoY2xhc3NOYW1lKSAmJiBzbGlkZUNsYXNzZXMucmVtb3ZlKGNsYXNzTmFtZSlcbiAgICAgIH0pXG4gICAgICBzbGlkZUNsYXNzZXMudG9nZ2xlKCdhY3RpdmUnLCBfLnNsaWRlID09PSBpbmRleClcbiAgICAgIGlmIChtaWRkbGUgPT09IGluZGV4IHx8IChleHRyYU1pZGRsZSAmJiBleHRyYU1pZGRsZSA9PT0gaW5kZXgpKSB7XG4gICAgICAgIHNsaWRlQ2xhc3Nlcy5hZGQoJ2NlbnRlcicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZUNsYXNzZXMucmVtb3ZlKCdjZW50ZXInKVxuICAgICAgICBzbGlkZUNsYXNzZXMuYWRkKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIGluZGV4IDwgbWlkZGxlID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgICAgICAgICAgIE1hdGguYWJzKGluZGV4IC0gKGluZGV4IDwgbWlkZGxlID8gbWlkZGxlIDogZXh0cmFNaWRkbGUgfHwgbWlkZGxlKSlcbiAgICAgICAgICBdLmpvaW4oJy0nKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHZhciBpc1Zpc2libGUgPVxuICAgICAgICBNYXRoLmNlaWwoaXRlbVN0YXJ0KSA+PSBzdGFydCAmJiBNYXRoLmNlaWwoaXRlbUVuZCkgPD0gZW5kXG4gICAgICBzbGlkZUNsYXNzZXMudG9nZ2xlKCd2aXNpYmxlJywgaXNWaXNpYmxlKVxuICAgICAgaWYgKGlzVmlzaWJsZSAhPT0gd2FzVmlzaWJsZSkge1xuICAgICAgICBfLmVtaXQoJ3NsaWRlLScgKyAoaXNWaXNpYmxlID8gJ3Zpc2libGUnIDogJ2hpZGRlbicpLCB7XG4gICAgICAgICAgc2xpZGU6IGluZGV4XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoXy5kb3RzKSB7XG4gICAgICBbXS5mb3JFYWNoLmNhbGwoXy5kb3RzLmNoaWxkcmVuLCBmdW5jdGlvbiAoZG90LCBpbmRleCkge1xuICAgICAgICBkb3QuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJywgXy5wYWdlID09PSBpbmRleClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ICYmIF8ub3B0LnNjcm9sbExvY2spIHtcbiAgICAgIGNsZWFyVGltZW91dChfLnNjcm9sbExvY2spXG4gICAgICBfLnNjcm9sbExvY2sgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF8uc2Nyb2xsTG9jaylcbiAgICAgICAgaWYgKChfLmVsZS5zY3JvbGxMZWZ0IC8gXy5pdGVtV2lkdGgpICUgMSkge1xuICAgICAgICAgIF8uc2Nyb2xsSXRlbShfLnJvdW5kKF8uZWxlLnNjcm9sbExlZnQgLyBfLml0ZW1XaWR0aCkpXG4gICAgICAgIH1cbiAgICAgIH0sIF8ub3B0LnNjcm9sbExvY2tEZWxheSB8fCAyNTApXG4gICAgfVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLnNjcm9sbEl0ZW0gPSBmdW5jdGlvbiAoc2xpZGUsIGRvdCwgZSkge1xuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIHZhciBfID0gdGhpc1xuXG4gICAgdmFyIG9yaWdpbmFsU2xpZGUgPSBzbGlkZVxuICAgICsrXy5hbmltYXRlX2lkXG5cbiAgICBpZiAoZG90ID09PSB0cnVlKSB7XG4gICAgICBzbGlkZSA9IHNsaWRlICogXy5jb250YWluZXJXaWR0aFxuICAgICAgc2xpZGUgPSBNYXRoLnJvdW5kKHNsaWRlIC8gXy5pdGVtV2lkdGgpICogXy5pdGVtV2lkdGhcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBzbGlkZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGJhY2t3YXJkcyA9IHNsaWRlID09PSAncHJldidcblxuICAgICAgICAvLyB1c2UgcHJlY2lzZSBsb2NhdGlvbiBpZiBmcmFjdGlvbmFsIHNsaWRlcyBhcmUgb25cbiAgICAgICAgaWYgKF8ub3B0LnNsaWRlc1RvU2Nyb2xsICUgMSB8fCBfLm9wdC5zbGlkZXNUb1Nob3cgJSAxKSB7XG4gICAgICAgICAgc2xpZGUgPSBfLnJvdW5kKF8uZWxlLnNjcm9sbExlZnQgLyBfLml0ZW1XaWR0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbGlkZSA9IF8uc2xpZGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYWNrd2FyZHMpIHNsaWRlIC09IF8ub3B0LnNsaWRlc1RvU2Nyb2xsXG4gICAgICAgIGVsc2Ugc2xpZGUgKz0gXy5vcHQuc2xpZGVzVG9TY3JvbGxcblxuICAgICAgICBpZiAoXy5vcHQucmV3aW5kKSB7XG4gICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBfLmVsZS5zY3JvbGxMZWZ0XG4gICAgICAgICAgc2xpZGUgPVxuICAgICAgICAgICAgYmFja3dhcmRzICYmICFzY3JvbGxMZWZ0XG4gICAgICAgICAgICAgID8gXy5zbGlkZXMubGVuZ3RoXG4gICAgICAgICAgICAgIDogIWJhY2t3YXJkcyAmJlxuICAgICAgICAgICAgICAgIHNjcm9sbExlZnQgKyBfLmNvbnRhaW5lcldpZHRoID49IE1hdGguZmxvb3IoXy50cmFja1dpZHRoKVxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogc2xpZGVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzbGlkZSA9IE1hdGgubWF4KE1hdGgubWluKHNsaWRlLCBfLnNsaWRlcy5sZW5ndGgpLCAwKVxuXG4gICAgICBfLnNsaWRlID0gc2xpZGVcbiAgICAgIHNsaWRlID0gXy5pdGVtV2lkdGggKiBzbGlkZVxuICAgIH1cblxuICAgIF8uc2Nyb2xsVG8oXG4gICAgICBzbGlkZSxcbiAgICAgIF8ub3B0LmR1cmF0aW9uICogTWF0aC5hYnMoXy5lbGUuc2Nyb2xsTGVmdCAtIHNsaWRlKSxcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXy51cGRhdGVDb250cm9scygpXG4gICAgICAgIF8uZW1pdCgnYW5pbWF0ZWQnLCB7XG4gICAgICAgICAgdmFsdWU6IG9yaWdpbmFsU2xpZGUsXG4gICAgICAgICAgdHlwZTpcbiAgICAgICAgICAgIHR5cGVvZiBvcmlnaW5hbFNsaWRlID09PSAnc3RyaW5nJyA/ICdhcnJvdycgOiBkb3QgPyAnZG90JyA6ICdzbGlkZSdcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5zZXR0aW5nc0JyZWFrcG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICB2YXIgcmVzcCA9IF8uX29wdC5yZXNwb25zaXZlXG5cbiAgICBpZiAocmVzcCkge1xuICAgICAgLy8gU29ydCB0aGUgYnJlYWtwb2ludHMgaW4gbW9iaWxlIGZpcnN0IG9yZGVyXG4gICAgICByZXNwLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIuYnJlYWtwb2ludCAtIGEuYnJlYWtwb2ludFxuICAgICAgfSlcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNwLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzaXplID0gcmVzcFtpXVxuICAgICAgICBpZiAoX3dpbmRvdy5pbm5lcldpZHRoID49IHNpemUuYnJlYWtwb2ludCkge1xuICAgICAgICAgIGlmIChfLmJyZWFrcG9pbnQgIT09IHNpemUuYnJlYWtwb2ludCkge1xuICAgICAgICAgICAgXy5vcHQgPSBPYmplY3QuYXNzaWduKHt9LCBfLl9vcHQsIHNpemUuc2V0dGluZ3MpXG4gICAgICAgICAgICBfLmJyZWFrcG9pbnQgPSBzaXplLmJyZWFrcG9pbnRcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBiYWNrIHRvIGRlZmF1bHRzIGluIGNhc2UgdGhleSB3ZXJlIG92ZXJyaWRlblxuICAgIHZhciBicmVha3BvaW50Q2hhbmdlZCA9IF8uYnJlYWtwb2ludCAhPT0gMFxuICAgIF8ub3B0ID0gT2JqZWN0LmFzc2lnbih7fSwgXy5fb3B0KVxuICAgIF8uYnJlYWtwb2ludCA9IDBcbiAgICByZXR1cm4gYnJlYWtwb2ludENoYW5nZWRcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uIChzY3JvbGxUYXJnZXQsIHNjcm9sbER1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIHZhciBfID0gdGhpc1xuXG4gICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKClcblxuICAgIHZhciBhbmltYXRlSW5kZXggPSBfLmFuaW1hdGVfaWRcblxuICAgIHZhciBhbmltYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRcbiAgICAgIF8uZWxlLnNjcm9sbExlZnQgPVxuICAgICAgICBfLmVsZS5zY3JvbGxMZWZ0ICtcbiAgICAgICAgKHNjcm9sbFRhcmdldCAtIF8uZWxlLnNjcm9sbExlZnQpICpcbiAgICAgICAgICBfLm9wdC5lYXNpbmcoMCwgbm93LCAwLCAxLCBzY3JvbGxEdXJhdGlvbilcbiAgICAgIGlmIChub3cgPCBzY3JvbGxEdXJhdGlvbiAmJiBhbmltYXRlSW5kZXggPT09IF8uYW5pbWF0ZV9pZCkge1xuICAgICAgICBfd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgXy5lbGUuc2Nyb2xsTGVmdCA9IHNjcm9sbFRhcmdldFxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKF8pXG4gICAgICB9XG4gICAgfVxuXG4gICAgX3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICBpZiAoXy5zbGlkZXMubGVuZ3RoKSB7XG4gICAgICBfLnRyYWNrLnJlbW92ZUNoaWxkKF8uc2xpZGVzW2luZGV4XSlcbiAgICAgIF8ucmVmcmVzaCh0cnVlKVxuICAgICAgXy5lbWl0KCdyZW1vdmUnKVxuICAgIH1cbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBfID0gdGhpc1xuXG4gICAgXy50cmFjay5hcHBlbmRDaGlsZChlbGUpXG4gICAgXy5yZWZyZXNoKHRydWUpXG4gICAgXy5lbWl0KCdhZGQnKVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLmhhbmRsZU1vdXNlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgXyA9IHRoaXNcbiAgICBpZiAoXy5tb3VzZURvd24pIHtcbiAgICAgIF8uZWxlLnNjcm9sbExlZnQgKz1cbiAgICAgICAgKF8ubW91c2VEb3duIC0gZS5jbGllbnRYKSAqIChfLm9wdC5kcmFnVmVsb2NpdHkgfHwgMy4zKVxuICAgICAgXy5tb3VzZURvd24gPSBlLmNsaWVudFhcbiAgICB9XG4gIH1cblxuICAvLyB1c2VkIHRvIHJvdW5kIHRvIHRoZSBuZWFyZXN0IDAuWFggZnJhY3Rpb25cbiAgZ2xpZGVyUHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24gKGRvdWJsZSkge1xuICAgIHZhciBfID0gdGhpc1xuICAgIHZhciBzdGVwID0gXy5vcHQuc2xpZGVzVG9TY3JvbGwgJSAxIHx8IDFcbiAgICB2YXIgaW52ID0gMS4wIC8gc3RlcFxuICAgIHJldHVybiBNYXRoLnJvdW5kKGRvdWJsZSAqIGludikgLyBpbnZcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKHBhZ2luZykge1xuICAgIHZhciBfID0gdGhpc1xuICAgIF8uaW5pdCh0cnVlLCBwYWdpbmcpXG4gIH1cblxuICBnbGlkZXJQcm90b3R5cGUuc2V0T3B0aW9uID0gZnVuY3Rpb24gKG9wdCwgZ2xvYmFsKSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICBpZiAoXy5icmVha3BvaW50ICYmICFnbG9iYWwpIHtcbiAgICAgIF8uX29wdC5yZXNwb25zaXZlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHYuYnJlYWtwb2ludCA9PT0gXy5icmVha3BvaW50KSB7XG4gICAgICAgICAgdi5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHYuc2V0dGluZ3MsIG9wdClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgXy5fb3B0ID0gT2JqZWN0LmFzc2lnbih7fSwgXy5fb3B0LCBvcHQpXG4gICAgfVxuXG4gICAgXy5icmVha3BvaW50ID0gMFxuICAgIF8uc2V0dGluZ3NCcmVha3BvaW50KClcbiAgfVxuXG4gIGdsaWRlclByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfID0gdGhpc1xuXG4gICAgdmFyIHJlcGxhY2UgPSBfLmVsZS5jbG9uZU5vZGUodHJ1ZSlcblxuICAgIHZhciBjbGVhciA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIGVsZS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICBbXS5mb3JFYWNoLmNhbGwoZWxlLmNsYXNzTGlzdCwgZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAvXmdsaWRlci8udGVzdChjbGFzc05hbWUpICYmIGVsZS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSlcbiAgICAgIH0pXG4gICAgfVxuICAgIC8vIHJlbW92ZSB0cmFja1xuICAgIHJlcGxhY2UuY2hpbGRyZW5bMF0ub3V0ZXJIVE1MID0gcmVwbGFjZS5jaGlsZHJlblswXS5pbm5lckhUTUxcbiAgICBjbGVhcihyZXBsYWNlKTtcbiAgICBbXS5mb3JFYWNoLmNhbGwocmVwbGFjZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpLCBjbGVhcilcbiAgICBfLmVsZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChyZXBsYWNlLCBfLmVsZSlcbiAgICBfLmV2ZW50KF93aW5kb3csICdyZW1vdmUnLCB7XG4gICAgICByZXNpemU6IF8ucmVzaXplXG4gICAgfSlcbiAgICBfLmVtaXQoJ2Rlc3Ryb3knKVxuICB9XG5cbiAgZ2xpZGVyUHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAobmFtZSwgYXJnKSB7XG4gICAgdmFyIF8gPSB0aGlzXG5cbiAgICB2YXIgZSA9IG5ldyBfd2luZG93LkN1c3RvbUV2ZW50KCdnbGlkZXItJyArIG5hbWUsIHtcbiAgICAgIGJ1YmJsZXM6ICFfLm9wdC5ldmVudFByb3BhZ2F0ZSxcbiAgICAgIGRldGFpbDogYXJnXG4gICAgfSlcbiAgICBfLmVsZS5kaXNwYXRjaEV2ZW50KGUpXG4gIH1cblxuICBnbGlkZXJQcm90b3R5cGUuZXZlbnQgPSBmdW5jdGlvbiAoZWxlLCB0eXBlLCBhcmdzKSB7XG4gICAgdmFyIGV2ZW50SGFuZGxlciA9IGVsZVt0eXBlICsgJ0V2ZW50TGlzdGVuZXInXS5iaW5kKGVsZSlcbiAgICBPYmplY3Qua2V5cyhhcmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBldmVudEhhbmRsZXIoaywgYXJnc1trXSlcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIEdsaWRlclxufSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/glider-js/glider.js\n"));

/***/ }),

/***/ "./node_modules/react-glider/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-glider/dist/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n// tslint:disable-next-line\n__webpack_require__(/*! glider-js */ \"./node_modules/glider-js/glider.js\");\nvar GliderComponent = React.forwardRef(function (props, ref) {\n    var innerRef = React.useRef(null);\n    var gliderRef = React.useRef();\n    var makeGliderOptions = function () { return (__assign(__assign({}, props), { arrows: (props.hasArrows && {\n            next: (props.arrows && props.arrows.next && props.arrows.next) ||\n                '.glider-next',\n            prev: (props.arrows && props.arrows.prev && props.arrows.prev) ||\n                '.glider-prev',\n        }) ||\n            undefined, dots: (props.hasDots && props.dots && props.dots) || '#dots' || 0 })); };\n    // On mount initialize the glider and hook up events\n    React.useLayoutEffect(function () {\n        if (!innerRef.current) {\n            return;\n        }\n        // @ts-ignore\n        var glider = new Glider(innerRef.current, makeGliderOptions());\n        gliderRef.current = glider;\n        var addEventListener = function (event, fn) {\n            if (typeof fn === 'function' && innerRef.current) {\n                innerRef.current.addEventListener(event, fn);\n            }\n        };\n        addEventListener('glider-slide-visible', props.onSlideVisible);\n        addEventListener('glider-loaded', props.onLoad);\n        addEventListener('glider-animated', props.onAnimated);\n        addEventListener('glider-remove', props.onRemove);\n        addEventListener('glider-refresh', props.onRefresh);\n        addEventListener('glider-add', props.onAdd);\n        addEventListener('glider-destroy', props.onDestroy);\n        addEventListener('glider-slide-hidden', props.onSlideHidden);\n        if (props.scrollToSlide) {\n            glider.scrollItem(props.scrollToSlide - 1);\n        }\n        else if (props.scrollToPage) {\n            glider.scrollItem(props.scrollToPage - 1, true);\n        }\n        return function () {\n            var removeEventListener = function (event, fn) {\n                if (typeof fn === 'function' && innerRef.current) {\n                    innerRef.current.removeEventListener(event, fn);\n                }\n            };\n            removeEventListener('glider-slide-visible', props.onSlideVisible);\n            removeEventListener('glider-loaded', props.onLoad);\n            removeEventListener('glider-animated', props.onAnimated);\n            removeEventListener('glider-remove', props.onRemove);\n            removeEventListener('glider-refresh', props.onRefresh);\n            removeEventListener('glider-add', props.onAdd);\n            removeEventListener('glider-destroy', props.onDestroy);\n            removeEventListener('glider-slide-hidden', props.onSlideHidden);\n            if (gliderRef.current) {\n                gliderRef.current.destroy();\n            }\n        };\n    }, []);\n    // When the props update, update the glider\n    React.useEffect(function () {\n        if (!gliderRef.current) {\n            return;\n        }\n        gliderRef.current.setOption(makeGliderOptions(), true);\n        gliderRef.current.refresh(true);\n    }, [props]);\n    // Expose the glider instance to the user so they can call the methods too\n    React.useImperativeHandle(ref, function () { return gliderRef.current; });\n    return (React.createElement(\"div\", { className: \"glider-contain\" },\n        props.hasArrows && !props.arrows && (React.createElement(\"button\", { role: \"button\", className: \"glider-prev\", id: \"glider-prev\" }, props.iconLeft || '«')),\n        React.createElement(\"div\", { className: props.className, ref: innerRef }, props.children),\n        props.hasDots && !props.dots && (React.createElement(\"div\", { id: \"dots\", className: \"glider-dots\" })),\n        props.hasArrows && !props.arrows && (React.createElement(\"button\", { role: \"button\", className: \"glider-next\", id: \"glider-next\" }, props.iconRight || '»'))));\n});\nexports[\"default\"] = GliderComponent;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZ2xpZGVyL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixtQkFBTyxDQUFDLDRDQUFPO0FBQ3hDO0FBQ0EsbUJBQU8sQ0FBQyxxREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCLFlBQVk7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUZBQXVGLENBQVMsRUFBRTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpREFBaUQsMkJBQTJCO0FBQzVFLHlDQUF5Qyw2QkFBNkI7QUFDdEUsNkVBQTZFLDZEQUE2RDtBQUMxSSxxQ0FBcUMsMkNBQTJDO0FBQ2hGLHNFQUFzRSxzQ0FBc0M7QUFDNUcsNkVBQTZFLDZEQUE2RDtBQUMxSSxDQUFDO0FBQ0Qsa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ2xpZGVyL2Rpc3QvaW5kZXguanM/Y2QyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbnJlcXVpcmUoXCJnbGlkZXItanNcIik7XG52YXIgR2xpZGVyQ29tcG9uZW50ID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIHZhciBpbm5lclJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICB2YXIgZ2xpZGVyUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gICAgdmFyIG1ha2VHbGlkZXJPcHRpb25zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcm9wcyksIHsgYXJyb3dzOiAocHJvcHMuaGFzQXJyb3dzICYmIHtcbiAgICAgICAgICAgIG5leHQ6IChwcm9wcy5hcnJvd3MgJiYgcHJvcHMuYXJyb3dzLm5leHQgJiYgcHJvcHMuYXJyb3dzLm5leHQpIHx8XG4gICAgICAgICAgICAgICAgJy5nbGlkZXItbmV4dCcsXG4gICAgICAgICAgICBwcmV2OiAocHJvcHMuYXJyb3dzICYmIHByb3BzLmFycm93cy5wcmV2ICYmIHByb3BzLmFycm93cy5wcmV2KSB8fFxuICAgICAgICAgICAgICAgICcuZ2xpZGVyLXByZXYnLFxuICAgICAgICB9KSB8fFxuICAgICAgICAgICAgdW5kZWZpbmVkLCBkb3RzOiAocHJvcHMuaGFzRG90cyAmJiBwcm9wcy5kb3RzICYmIHByb3BzLmRvdHMpIHx8ICcjZG90cycgfHwgdW5kZWZpbmVkIH0pKTsgfTtcbiAgICAvLyBPbiBtb3VudCBpbml0aWFsaXplIHRoZSBnbGlkZXIgYW5kIGhvb2sgdXAgZXZlbnRzXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpbm5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB2YXIgZ2xpZGVyID0gbmV3IEdsaWRlcihpbm5lclJlZi5jdXJyZW50LCBtYWtlR2xpZGVyT3B0aW9ucygpKTtcbiAgICAgICAgZ2xpZGVyUmVmLmN1cnJlbnQgPSBnbGlkZXI7XG4gICAgICAgIHZhciBhZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpbm5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaW5uZXJSZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2dsaWRlci1zbGlkZS12aXNpYmxlJywgcHJvcHMub25TbGlkZVZpc2libGUpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdnbGlkZXItbG9hZGVkJywgcHJvcHMub25Mb2FkKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignZ2xpZGVyLWFuaW1hdGVkJywgcHJvcHMub25BbmltYXRlZCk7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2dsaWRlci1yZW1vdmUnLCBwcm9wcy5vblJlbW92ZSk7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2dsaWRlci1yZWZyZXNoJywgcHJvcHMub25SZWZyZXNoKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignZ2xpZGVyLWFkZCcsIHByb3BzLm9uQWRkKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignZ2xpZGVyLWRlc3Ryb3knLCBwcm9wcy5vbkRlc3Ryb3kpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdnbGlkZXItc2xpZGUtaGlkZGVuJywgcHJvcHMub25TbGlkZUhpZGRlbik7XG4gICAgICAgIGlmIChwcm9wcy5zY3JvbGxUb1NsaWRlKSB7XG4gICAgICAgICAgICBnbGlkZXIuc2Nyb2xsSXRlbShwcm9wcy5zY3JvbGxUb1NsaWRlIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvcHMuc2Nyb2xsVG9QYWdlKSB7XG4gICAgICAgICAgICBnbGlkZXIuc2Nyb2xsSXRlbShwcm9wcy5zY3JvbGxUb1BhZ2UgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpbm5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyUmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdnbGlkZXItc2xpZGUtdmlzaWJsZScsIHByb3BzLm9uU2xpZGVWaXNpYmxlKTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dsaWRlci1sb2FkZWQnLCBwcm9wcy5vbkxvYWQpO1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2xpZGVyLWFuaW1hdGVkJywgcHJvcHMub25BbmltYXRlZCk7XG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdnbGlkZXItcmVtb3ZlJywgcHJvcHMub25SZW1vdmUpO1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2xpZGVyLXJlZnJlc2gnLCBwcm9wcy5vblJlZnJlc2gpO1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignZ2xpZGVyLWFkZCcsIHByb3BzLm9uQWRkKTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dsaWRlci1kZXN0cm95JywgcHJvcHMub25EZXN0cm95KTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dsaWRlci1zbGlkZS1oaWRkZW4nLCBwcm9wcy5vblNsaWRlSGlkZGVuKTtcbiAgICAgICAgICAgIGlmIChnbGlkZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGdsaWRlclJlZi5jdXJyZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgLy8gV2hlbiB0aGUgcHJvcHMgdXBkYXRlLCB1cGRhdGUgdGhlIGdsaWRlclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZ2xpZGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBnbGlkZXJSZWYuY3VycmVudC5zZXRPcHRpb24obWFrZUdsaWRlck9wdGlvbnMoKSwgdHJ1ZSk7XG4gICAgICAgIGdsaWRlclJlZi5jdXJyZW50LnJlZnJlc2godHJ1ZSk7XG4gICAgfSwgW3Byb3BzXSk7XG4gICAgLy8gRXhwb3NlIHRoZSBnbGlkZXIgaW5zdGFuY2UgdG8gdGhlIHVzZXIgc28gdGhleSBjYW4gY2FsbCB0aGUgbWV0aG9kcyB0b29cbiAgICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2xpZGVyUmVmLmN1cnJlbnQ7IH0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJnbGlkZXItY29udGFpblwiIH0sXG4gICAgICAgIHByb3BzLmhhc0Fycm93cyAmJiAhcHJvcHMuYXJyb3dzICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgcm9sZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBcImdsaWRlci1wcmV2XCIsIGlkOiBcImdsaWRlci1wcmV2XCIgfSwgcHJvcHMuaWNvbkxlZnQgfHwgJ8KrJykpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWUsIHJlZjogaW5uZXJSZWYgfSwgcHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICBwcm9wcy5oYXNEb3RzICYmICFwcm9wcy5kb3RzICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IFwiZG90c1wiLCBjbGFzc05hbWU6IFwiZ2xpZGVyLWRvdHNcIiB9KSksXG4gICAgICAgIHByb3BzLmhhc0Fycm93cyAmJiAhcHJvcHMuYXJyb3dzICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgcm9sZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBcImdsaWRlci1uZXh0XCIsIGlkOiBcImdsaWRlci1uZXh0XCIgfSwgcHJvcHMuaWNvblJpZ2h0IHx8ICfCuycpKSkpO1xufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBHbGlkZXJDb21wb25lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-glider/dist/index.js\n"));

/***/ })

}]);